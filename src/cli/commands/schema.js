const { Command } = require('commander');
const readline = require('readline');
const glob = require('glob');
const { promisify } = require('util');
const SchemaGenerator = require('../../services/SchemaGenerator');
const SchemaManager = require('../../services/SchemaManager');
const logger = require('../../utils/logger');
const { formatError } = require('../output');

const globAsync = promisify(glob);

const schemaCommand = new Command('schema')
  .description('Manage custom document schemas');

schemaCommand
  .command('propose')
  .description('Propose a new schema from example files')
  .argument('<files...>', 'Path to example files (glob support)')
  .action(async (files) => {
    try {
      // 1. Resolve files
      // Commander might pass an array if multiple args, or single string. 
      // If user uses shell expansion, we get array of files. If quoted glob, we get string.
      // We should flatten and expand.
      let allFiles = [];
      for (const pattern of files) {
        const matches = await globAsync(pattern);
        allFiles = allFiles.concat(matches);
      }

      if (allFiles.length === 0) {
        throw new Error('No files found matching the provided patterns.');
      }

      console.log(`Analyzing ${allFiles.length} files...`);

      // 2. Initialize Generator
      // Assuming singleton or new instance needed. Services usually instantiated with config/logger
      // But SchemaGenerator might just need standard env config.
      // Let's instantiate locally for the command.
      const generator = new SchemaGenerator();

      // 3. Generate Schema
      const analysis = await generator.generateSchema(allFiles);

      // 4. Present to User
      console.log('\n--- Proposed Schema ---');
      console.log(`Recommended Name: ${analysis.recommendedName}`);
      console.table(analysis.fields.map(f => ({
        Name: f.name,
        Type: f.type,
        Description: f.description
      })));
      console.log('-----------------------\n');

      // 5. Confirm Save
      const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
      });

      const question = (query) => new Promise(resolve => rl.question(query, resolve));

      const answer = await question(`Save this schema as "${analysis.recommendedName}"? [Y/n] `);
      rl.close();

      if (answer.toLowerCase() === 'y' || answer === '') {
        const db = require('../../utils/database'); // SchemaManager needs db
        // const manager = new SchemaManager(db);

        // Construct full definition
        // Analysis result might be partial, we need to wrap it into a definition expected by createSchema?
        // Or SchemaGenerator returns a full definition?
        // Design says SchemaGenerator returns "SchemaAnalysisResult".
        // SchemaManager.createSchema expects "CustomSchema" (minus params generated by manager like ID).
        // Let's assume we map AnalysisResult to the definition.

        const schemaDefinition = {
          name: analysis.recommendedName,
          // We need a unique table name. Manager might handle sanitization but we should provide suggestion?
          // Design says: "Sanitized SQL table name". Generator should probably return this or Manager generates it.
          // Let's assume Manager handles table name derivation from name if not provided, or we perform it.
          // Re-reading design: "Component 1: SchemaGenerator... Suggest a valid SQL table name."
          // So analysis likely has tableName.
          tableName: analysis.tableName || `custom_${analysis.recommendedName.toLowerCase().replace(/[^a-z0-9]/g, '_')}`,
          jsonSchema: analysis.jsonSchema,
          systemPrompt: analysis.systemPrompt,
          userPromptTemplate: analysis.userPromptTemplate
        };

        const result = await SchemaManager.createSchema(schemaDefinition);
        console.log(`\nSchema saved successfully! ID: ${result.id}`);
      } else {
        console.log('\nSchema discarded.');
      }

    } catch (error) {
      formatError(error);
      process.exit(1);
    }
  });

schemaCommand
  .command('list')
  .description('List all available custom schemas')
  .action(async () => {
    try {
      // const db = require('../../utils/database');
      // const manager = new SchemaManager(db);
      const schemas = await SchemaManager.listSchemas();

      if (schemas.length === 0) {
        console.log('No custom schemas found.');
        return;
      }

      console.table(schemas.map(s => ({
        ID: s.id,
        Name: s.name,
        Table: s.table_name,
        Created: s.created_at
      })));

    } catch (error) {
      formatError(error);
      process.exit(1);
    }
  });

module.exports = schemaCommand;
